"""
Data models and type definitions for the trading system.
"""
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, List, Dict, Any, Tuple
from enum import Enum
import pandas as pd


class SignalType(Enum):
    """Signal types for trading decisions."""
    BUY_CALL = "buy_call"
    BUY_PUT = "buy_put"
    SELL_CALL = "sell_call"
    SELL_PUT = "sell_put"
    HOLD = "hold"


class OrderType(Enum):
    """Order types."""
    MARKET = "market"
    LIMIT = "limit"
    STOP_LOSS = "stop_loss"


class OrderStatus(Enum):
    """Order status."""
    PENDING = "pending"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


class PositionSide(Enum):
    """Position side."""
    LONG = "long"
    SHORT = "short"


@dataclass
class Channel:
    """Channel detection result."""
    start_ts: datetime
    end_ts: datetime
    upper_line: Dict[str, float]  # {"slope": float, "intercept": float}
    lower_line: Dict[str, float]  # {"slope": float, "intercept": float}
    touches_upper: int
    touches_lower: int
    is_upward: bool
    valid: bool
    confidence: float = 0.0
    upper_points: List[Tuple[datetime, float]] = field(default_factory=list)
    lower_points: List[Tuple[datetime, float]] = field(default_factory=list)


@dataclass
class KSTSignal:
    """No-Sure-Thing (KST) indicator signal."""
    kst_value: float
    kst_signal: float
    crossover_direction: str  # "bullish", "bearish", "none"
    timestamp: datetime
    confidence: float = 0.0


@dataclass
class TradeSignal:
    """Trading signal generated by the strategy."""
    signal_type: SignalType
    instrument: str
    strike: int
    option_type: str  # "CE" or "PE"
    entry_price: float
    target_price: Optional[float] = None
    stop_loss_price: Optional[float] = None
    quantity: int = 1
    timestamp: datetime = field(default_factory=datetime.now)
    reason: str = ""
    confidence: float = 0.0
    channel_data: Optional[Channel] = None
    kst_data: Optional[KSTSignal] = None


@dataclass
class Position:
    """Open position in the market."""
    id: str
    instrument: str
    strike: int
    option_type: str
    side: PositionSide
    quantity: int
    entry_price: float
    entry_time: datetime
    target_price: Optional[float] = None
    stop_loss_price: Optional[float] = None
    current_price: float = 0.0
    unrealized_pnl: float = 0.0
    channel_data: Optional[Channel] = None
    kst_data: Optional[KSTSignal] = None


@dataclass
class Trade:
    """Completed trade record."""
    id: str
    instrument: str
    strike: int
    option_type: str
    side: PositionSide
    quantity: int
    entry_price: float
    exit_price: float
    entry_time: datetime
    exit_time: datetime
    pnl: float
    fees: float = 0.0
    reason: str = ""
    channel_data: Optional[Dict[str, Any]] = None
    kst_data: Optional[Dict[str, Any]] = None


@dataclass
class MarketData:
    """Market data for a specific instrument."""
    instrument: str
    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: int
    oi: Optional[int] = None


@dataclass
class BrokerResponse:
    """Standardized broker API response."""
    success: bool
    data: Optional[Any] = None
    error: Optional[str] = None
    order_id: Optional[str] = None
    filled_price: Optional[float] = None
    timestamp: datetime = field(default_factory=datetime.now)


@dataclass
class SystemStatus:
    """System status information."""
    running: bool
    last_run_time: Optional[datetime]
    last_candle_time: Optional[datetime]
    open_positions: List[Position]
    today_trades: List[Trade]
    total_trades: int
    total_pnl: float
    win_rate: float
    error_count: int
    last_error: Optional[str]
    strategy_start_time: Optional[datetime]


@dataclass
class PerformanceMetrics:
    """Performance metrics for the strategy."""
    total_trades: int
    winning_trades: int
    losing_trades: int
    win_rate: float
    total_pnl: float
    max_drawdown: float
    sharpe_ratio: float
    avg_trade_pnl: float
    best_trade: float
    worst_trade: float
    profit_factor: float
    avg_holding_time: float  # in minutes


@dataclass
class ChannelDetectionParams:
    """Parameters for channel detection algorithm."""
    min_touches: int = 2
    min_days: int = 7
    lookback_days: int = 30
    tolerance_percent: float = 2.0
    min_channel_width: float = 0.5  # Minimum channel width as % of price


@dataclass
class KSTParams:
    """Parameters for KST indicator."""
    roc1: int = 10
    roc2: int = 15
    roc3: int = 20
    roc4: int = 30
    sma1: int = 10
    sma2: int = 10
    sma3: int = 10
    sma4: int = 15
    signal_period: int = 9


def position_to_dict(position: Position) -> Dict[str, Any]:
    """Convert Position to dictionary for JSON serialization."""
    return {
        "id": position.id,
        "instrument": position.instrument,
        "strike": position.strike,
        "option_type": position.option_type,
        "side": position.side.value,
        "quantity": position.quantity,
        "entry_price": position.entry_price,
        "entry_time": position.entry_time.isoformat(),
        "target_price": position.target_price,
        "stop_loss_price": position.stop_loss_price,
        "current_price": position.current_price,
        "unrealized_pnl": position.unrealized_pnl,
        "channel_data": position.channel_data.__dict__ if position.channel_data else None,
        "kst_data": position.kst_data.__dict__ if position.kst_data else None
    }


def trade_to_dict(trade: Trade) -> Dict[str, Any]:
    """Convert Trade to dictionary for JSON serialization."""
    return {
        "id": trade.id,
        "instrument": trade.instrument,
        "strike": trade.strike,
        "option_type": trade.option_type,
        "side": trade.side.value,
        "quantity": trade.quantity,
        "entry_price": trade.entry_price,
        "exit_price": trade.exit_price,
        "entry_time": trade.entry_time.isoformat(),
        "exit_time": trade.exit_time.isoformat(),
        "pnl": trade.pnl,
        "fees": trade.fees,
        "reason": trade.reason,
        "channel_data": trade.channel_data,
        "kst_data": trade.kst_data
    }


def signal_to_dict(signal: TradeSignal) -> Dict[str, Any]:
    """Convert TradeSignal to dictionary for JSON serialization."""
    return {
        "signal_type": signal.signal_type.value,
        "instrument": signal.instrument,
        "strike": signal.strike,
        "option_type": signal.option_type,
        "entry_price": signal.entry_price,
        "target_price": signal.target_price,
        "stop_loss_price": signal.stop_loss_price,
        "quantity": signal.quantity,
        "timestamp": signal.timestamp.isoformat(),
        "reason": signal.reason,
        "confidence": signal.confidence,
        "channel_data": signal.channel_data.__dict__ if signal.channel_data else None,
        "kst_data": signal.kst_data.__dict__ if signal.kst_data else None
    }